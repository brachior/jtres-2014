\documentclass{sig-alternate}

\usepackage{tikz}
\usetikzlibrary{plotmarks,arrows,positioning}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{hyperref}
\hypersetup{
    bookmarks=false,        % show bookmarks bar?
    unicode=false,          % non-Latin characters in Acrobat’s bookmarks
    pdftoolbar=true,        % show Acrobat’s toolbar?
    pdfmenubar=true,        % show Acrobat’s menu?
    pdffitwindow=false,     % window fit to page when opened
    pdfstartview={FitH},    % fits the width of the page to the window
    pdftitle={My title},    % title
    pdfauthor={Author},     % author
    pdfsubject={Subject},   % subject of the document
    pdfcreator={Creator},   % creator of the document
    pdfproducer={Producer}, % producer of the document
    pdfkeywords={keyword1} {key2} {key3}, % list of keywords
    pdfnewwindow=true,      % links in new window
    colorlinks=true,        % false: boxed links; true: colored links
    linkcolor=black,        % color of internal links (change box color with linkbordercolor)
    citecolor=black,        % color of links to bibliography
    filecolor=black,        % color of file links
    urlcolor=black          % color of external links
}

\def \JCP{JCP\xspace}
\def \SUN{Sun Microsystems\xspace}
\def \ORACLE{Oracle\xspace}
\def \DALVIK{Dalvik\xspace}
\def \Jsr{JSR\xspace}
\def \JSR{\Jsr 292\xspace}
\def \GOOGLE{Google\xspace}
\def \ANDROID{Android\xspace}
\def \JVM{JVM\xspace}
\def \DEX{DEX\xspace}
\def \VM{VM\xspace}
\def \BSM{BSM\xspace}

\newcommand{\tinyline}[3]{
  \tiny #1 &
  \tiny #2 &
  \tiny #3\\
  \hline
}

\newenvironment{listminimal}[1]%
{ \begin{minipage}{#1}%
    \medskip
    \begin{list}%
      {}%
      {%
        \setlength{\labelwidth}{0pt}%
        \setlength{\leftmargin}{0pt}%
        \setlength{\itemsep}{1pt}%
        \setlength{\parskip}{0pt}%
        \setlength{\parsep}{0pt}}%
}%
{ \\ \end{list} \end{minipage} }

\newcommand{\fixme}[1]{{\color{red}FIXME #1}}

\begin{document}

\title{Android 292: implementing invokedynamic in Android}

\numberofauthors{3}
\author{
  \alignauthor Gilles Roussel\\
    \affaddr{University Paris-Est Marne-la-Vallee}\\
    \email{roussel@univ-mlv.fr}
  \alignauthor Remi Forax\\
    \affaddr{University Paris-Est Marne-la-Vallee}\\
    \email{forax@univ-mlv.fr}
  \alignauthor Jerome Pilliet\\
    \affaddr{University Paris-Est Marne-la-Vallee}\\
    \email{pilliet@univ-mlv.fr}
}

\conferenceinfo{JTRES}{2014 Niagara Falls, New York USA}
%\CopyrightYear{2007} % Allows default copyright year (20XX) to be over-ridden - IF NEED BE.
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data (0-89791-88-6/97/05) to be over-ridden - IF NEED BE.
% --- End of Author Metadata ---

\maketitle

\begin{abstract}
Android OS uses for its applicative part, a Java-based virtual machine called Dalvik.
Java 7 introduces a new instructions set as well as a new API  specified by the \JSR
in order to improve and simplify the implementation of non-Java languages on top of the Java Virtual Machine.
A far as we know, neither the JVMs that are compatible with Java ME 8 nor
Android, while compatible at syntactical level with Java 7, implement this \Jsr.
We believe this is due to the fact that current implementations for desktop and server rely
on code generation at runtime which require too much computing power and energy.

This paper describes our implementation of the \JSR in Dalvik.
First, we adapt the class format specification of the \JSR which is stack based and implicitly rely on the fact that the bytecode
can be rewritten at runtime to the opcode specification of Dalvik wich is register based and read only. 
Then we explain, how we represent the different kinds of method handles in Java, and how the method handles are interpreted,
using either the C interpreter for the low level method handle or a Java flexible but slow interpreter for the ``combiner`` method handle.

At the end, we present a comparison of the execution time of the different kind of calls.
This comparison shows that the implementation of the new instructions are faster than the reflection
although the Java interpreter of combiners is slowed down by frequent objects creation.
\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore, 
% you may leave them out
% \terms
% term1, term2

\keywords
Bytecode, method invocation, invokedynamic, JSR 292,\\
method handles, method handle adapters, Android, Dalvik, embedded system

\section{Overview}

  \subsection{Android}

    \ANDROID is the mobile operating system created by Google.
    It is an open-source project called ``\ANDROID Open-Source Project'' (AOSP).
    In Q2 2013, \ANDROID occupies almost 80\% of the market share with more than 187 million units shipped \cite{idc-website}.
    The success of \ANDROID can be explained by an open project and an open market
    which are very attractive for devices producers, service providers and application developers \cite{ieee-butler-android-landscape}\cite{ieee-paulson-shift-dynamic-languages}.

    \ANDROID mainly run on embedded environments like smartphones and tablets.
    Therefore, strong constraints apply to \ANDROID
    and it have to support ARM architecture and now Intel architecture.
    
    Even if hardwares supporting \ANDROID become more efficients,
    devices cannot be more powerful than desktop computer because of miniaturization.
    Being a mobile device also requires a minimal energetic consumption.
    Moreover, \ANDROID is portable system and it have to be adaptable to different devices.
    Forcing it to abstract itself from hardware.

    The \ANDROID architecture is described like a ``software stack'' (Figure \ref{ASA}).
    It's composed of:
    \begin{itemize}
      \item a modified version of the Linux kernel.
        It offers an hardware abstraction, an existing memory, process managements and a security and networking models;
      \item native libraries (C/C++)
        which provide most of features in the \ANDROID system;
      \item a virtual machine called ``\DALVIK''.
        It is a important component of \ANDROID.
        It runs applications converted to the \DEX format.
        \DALVIK uses a core API written from scratch in Java
        which can be assimilated to the version 5 or 6 of the Java API;
      \item an application framework to enable the making of \ANDROID applications;
      \item and some default applications.
    \end{itemize}

    \subsubsection{Differences between the JVM and \DALVIK}

      The main difference between these two machines is that \DALVIK is register based while the \JVM is stack based.
      A stack based virutal machine (VM) uses more instructions to manipulate data and to implement Java code than a register based VM.
      But the register based VM instructions tends to be larger in terms of code size\cite{ieee-paul-kundu-energy-perspective}.

      \begin{figure}[!h]
        \centering \resizebox{\linewidth}{!}{\input{figures/tikz_struct_jar_apk}}
        \caption{structure of JAR and APK files.}
        \label{SJA}
      \end{figure}

      The bytecode Java is given in a ``.class'' file and contains the code of a unique class (Figure \ref{SJA}).
      The file is made of a series of tables which describes various informations, the code of the class and some other things.
      The code contains references to these tables.
      Among these tables, the constant-pool stores most of the constant values of the class (numbers or texts)
      and more evolved elements (data types, class names, attribute names, \dots).

      At the opposite, \DEX format contains all the code of the application (Figure \ref{SJA}).
      It will be loaded in one piece.
      It is a read-only format, the code cannot be changed at runtime.
      Duplicate constants such as strings used in multiple class files
      are included only once in the \DEX file to save space.
      Unlike the \JVM, \DALVIK uses one constant-pool by type of constant
      except for the primitive types which are directly encoded with the opcode.
      It leads more smaller indexes for instructions.\\

      \begin{figure}[!h]
        \centering \resizebox{\linewidth}{!}{\input{figures/tikz_dex_toolschain}}
        \caption{\ANDROID application tools-chain.}
        \label{DTC}
      \end{figure}

      \DALVIK cannot directly execute Java bytecode.
      It first have to translate the Java bytecode to the \DALVIK specific one called \DEX
      which can then be optimized (\mbox{ODEX}) to save space (Figure \ref{DTC}).

    \begin{figure}[!h]
      \centering \resizebox{\linewidth}{!}{\input{figures/tikz_struct_android}}
      \caption{android system architecture \cite{wiki-android}.}
      \label{ASA}
    \end{figure}

  \subsection{Java Specification Request 292}

    The \JSR is a request from \JCP and led by \SUN from 2006 to 2011.
    It had been integrated in 2011 in the version 7 of Java,
    modifying both the Java language specification and the \JVM specification.

    Since late 90's, a lot of language
    implementors have chosen the JVM as their target platform \cite{wiki-jvm-lang},
    for several reasons such as the size of the ecosystem,
    the presence of mature GCs and Just In Time compilers (JIT).

    The aim of this \Jsr is to ease the implementation of dynamically typed languages
    by providing a new way to do function calls that allows language implementors
    to describe a specific semantics, independantly of the semantics of the Java language.

    This \Jsr is composed of two parts, the first part, specifying the semantics of
    new opcodes and the second part defining an API: java.lang.invoke.
    This API allows to create runtime typesafe function pointers (java.lang.invoke.MethodHandle)
    and methods to combine those pointers to do things like composition, argument permutation, \dots.

    The next sections will present the new API and the new instructions but before that,
    we want to introduce an example that we will use for the rest of the paper.

    \subsubsection{Example}
      Let suppose we have the following code in Groovy \cite{lang-groovy}:

      \input{figures/snip_foo_groovy}

      It prints {\it '11'} and {\it 'test2'}.
      For the first call to {\bf foo}, {\bf a} is an integer so the symbol {\bf +} refers
      to the function {\it +(int,int)} while for the second call to {\bf foo}, {\bf a} is a string, {\bf +} refers to the function {\it +(String,String)}.

      If one try to translate this code in Java bytecode, it would be something like:

      \input{figures/snip_foo_bytecode}

      As you can see, the Java bytecode is typed, each instruction is prefixed 
      by the type of the operand ('a' for object, 'i' for integer, etc)
      and the method call (invokevirtual) specifies the type of the receiver and its parameters;
      an object (java/lang/Object) followed by an integer (I) ; and its return type
      which is also an object in the example.

      The code above does not work because invokevirtual is an existing Java bytecode that calls
      a virtual method using the Java semantics so the Virtual Machine or more precisely
      the bytecode verifier will check that there exists a method '+' on java.lang.Object
      that takes an integer and returns an Object. If you have already used Java, you know
      that this method does not exist. The bytecode verification will then fail.

      Another possible translation is to use a cascade of if ... instanceof.

      \input{figures/snip_foo_java}

      While this code works, it supposes that all the potentials variations of + are known at compile time,
      something which is not true in most dynamic languages (Ruby, Groovy, Dart by example).
      This code can also be slow because in real languages, the number of if ... instanceof branches
      can be greater than a dozen. 

      To solve these issues, the \Jsr introduces a new bytecode named invokedynamic with no predefined
      linking semantics. It introduces also a mechanism that allows to specify the linking semantics in Java
      or any languages that can be compiled to bytecodes.
      Invokedynamic is a function call so it can simulate every other existing Java calls.
      It delegates its linking semantics to an external Java method, the bootstrap method.
      This method returns a CallSite object which is a box that contains a function pointer (MethodHandle).

      The \JSR has created a new package named\\ ``java.lang.invoke''.
      It is composed of classes MethodType, MethodHandle and CallSite.
      These classes are directly understood by the \JVM.
      All classes answer to one or more problems coming from dynamic languages optimizations or implementations.

    \subsubsection{invoke-dynamic and MethodHandle}

      The bootstrap method is called the first time the invokedynamic opcode is encountered by the interpreter,
      with the context where the opcode is located i.e.~the declaring class (encapsulated in a Lookup object),
      a symbolic name and the declared parameter types as a MethodType.
      Any subsequent execution of the invokedynamic opcode will call the function pointer
      stored inside the callsite object returned by the bootstrap method.
      
      For our example, the code of {\bf foo} with invokedynamic is

      \input{figures/snip_foo_indy}

      The first time that {\bf foo} is executed, the bootstrap method of the class RT will be called, with a lookup corresponding to the class containing {\bf foo},
      the string {\bf ``+''} and a MethodType corresponding to the descriptor ``(LObject;I)LObject;'' (Figure \ref{fooBSM}).

      \begin{figure}[!h]
        \centering \input{figures/snip_foo_bsm}\vspace{-1.5em}
        \caption{Example - bootstrap method.}
        \label{fooBSM}
      \end{figure}

      Moreover, invokedynamic comes with an API that allows to create several data patterns
      dynamically and lazily like for example a tree of if ... instanceof branches.

    \subsubsection{MethodType}

      A method type represents the types of the arguments and the return value accepted and returned by a method handle,
      or expected by a method handle caller.
      This class represents a method signature.

      \begin{figure}[!h]
        \centering \input{figures/snip_foo_methods}\vspace{-1.5em}
        \caption{Example - methods with method types.}
        \label{fooMTS}
      \end{figure}

      All method types are immutable and interned.
      It can only be created by factory methods.
      In our example, we need three method types (Figure \ref{fooMTS}), one for each method that we have to call:
      the ``check'' method; and the two methods ``plus''.

    \subsubsection{MethodHandle / MethodHandles}
      \label{MH}

      A method handle is a runtime type checked, directly executable reference to
      either an underlying method, constructor, field, or similar low-level operation.
      It also represents a combiner operation that takes one or more method handles as input and
      applies an operation like an argument transformation, a function compositions, etc.
      The former kind of method handle is called {\it direct method handle},
      the later is called a {\it combiner method handle}.

      To guarantee runtime type safety, each method handle embodies a method type (of type MethodType)
      that describes the parameter types and the return type that a method handle accepts.
      When a method handle is called, the method type is checked using different semantics depending on the
      type of call.

      There are two kinds of method handle call semantics:
      \begin{itemize}
        \item the exact call semantics, in that case, the declared type of the arguments (and return value) at a call site
              must be exactly the same as the types of the method type.
        \item the generic call semantics, in that case, the arguments can be converted using widening primitive conversions,
              boxing and unboxing conversions and varargs conversions as defined in the Java Language Specification.
      \end{itemize}
      None of these semantics implements the calling semantics as defined by the Java Virtual Machine Specification
      for classical Java method calls like invokestatic or invokevirtual
      \footnote{There is also a minor difference between the generic call semantics and the call semantics of
        the Java Language Specification if the method is a varargs and the call as the same number of parameters as the method.
        The generic call semantics will not try to do the varargs conversion if the last parameter is not an array.},
      the exact call semantics is more strict, and the generic call semantics is more permissive.

      We can distinguish two kinds of method handle:
      the one which do a direct call to a method or to a field access, this method handle is direct;
      and the one which manipulates arguments called ``combiners''.
      The combiners contain at least one direct method handle and can be represented by a tree.

      In our example, we want to call a method which takes an Object and an integer and returns an Object.
      We need to resolve the right method to call (addition or concatenation).
      In order to do that, we write a method which will create the right method handle called {\bf change} (detailed after).

      \begin{figure}[!h]
        \centering \input{figures/snip_foo_callsite}\vspace{-1.5em}
        \caption{Example - mutable call site.}
        \label{fooMCS}
      \end{figure}

      We need to adapt the arguments to move from an Object and an integer to a CallSite and an array of Object.
      To do this we convert arguments (asType), we collect them to form the array of Objects (asCollector) and we add the call site at first argument (bindTo) (Figure \ref{fooMCS}).

      \noindent This adaptation forms the tree of the Figure \ref{ast1}.

      % graph 1
      \begin{figure}[!h]
        \centering \resizebox{.7\linewidth}{!}{\input{figures/tikz_ast_1}}
        \caption{Method handles tree - bootstrap method.}
        \label{ast1}
      \end{figure}

      When the call site is created, the method handle tree is called, so the {\bf change} method (Figure \ref{fooCHANGE}) is called.
      This method takes a look at the dynamic type of {\bf a} (let say an integer),
      finds the corresponding implementation of the {\bf plus} method
      and then re-links a method handles tree represented by a combiner called {\bf GuardWithTest}.
      This combiner uses the {\bf check} method to verify the class of {\bf a}.
      If the type of {\bf a} is an integer it will directly call the same implementation of {\bf plus};
      otherwise it uses the previous method handle tree.

      \begin{figure}[!h]
        \centering \input{figures/snip_foo_change}\vspace{-1.5em}
        \caption{Example - ``change'' method.}
        \label{fooCHANGE}
      \end{figure}

      To call the {\bf check} method, we have to adapt arguments.
      The stack contains an Object and an integer, we need an Object and a java.lang.Class.
      So we have to drop the integer (dropArguments) and insert the class (insertArguments).
      This adaptation forms the tree of the Figure \ref{ast2}.

      % graph 2
      \begin{figure}[!h]
        \hspace{-.6in} \resizebox{1.3\linewidth}{!}{\input{figures/tikz_ast_2}}
        \caption{Method handles tree - first call (integer).}
        \label{ast2}
      \end{figure}

      If 'a' is a string, the method {\bf change} is called again,
      installing a new method handle tree testing if 'a' is a string in order to call {\it plus(String,int)Object}.
      This adaptation form the tree of the Figure \ref{ast3}.

      % graph 3
      \begin{figure*}
        \centering \resizebox{.9\linewidth}{!}{\input{figures/tikz_ast_3}}
        \caption{Method handles tree - second call (string).}
        \label{ast3}
      \end{figure*}

    \subsubsection{CallSite}

      A CallSite is a holder for a variable MethodHandle, which is called its target.
      An invokedynamic instruction linked to a CallSite delegates all calls to the site's current target.
      A CallSite may be associated with several invokedynamic instructions,
      or it may be ``free floating'', associated with none.\\

      It has three immediate, concrete subclasses that may be either instantiated or subclassed:
      \begin{enumerate}
        \item \textbf{ConstantCallSite} : If a mutable target is not required.
        \item \textbf{MutableCallSite}  : If a mutable target is required.
        \item \textbf{VolatileCallSite} : If a mutable target is required which has volatile variable semantics.
      \end{enumerate}
      A non-constant call site may be relinked by changing its target, calling ``setTarget'' on the CallSite.
      The new target must have the same type as the previous one.

\section{Android 292}
  Currently the desktop and the server version (HotSpot, J9, \dots) of the JVM are the only one having a complete implementation of the JSR 292.
  These implementations use mechanisms that we cannot reuse with \DALVIK (code generation, rewriting,
  \dots~\cite{jvmsummit-heidinga-mhimpl-2010}\cite{jvmsummit-heidinga-mhimpl-2011}\cite{jvmsummit-rose-mhimpl-2011})
  because of the power costs and computing restrictions.
  For this reason, \DALVIK is seen like a specific virtual machine for language developers.
    
  Our solution is to make an implementation of the JSR 292 for Android but,
  because Android have many constraints from its environment,
  we have to reinterpret the JSR.
  The API stays the same, but the VM specification does not.

  The next sections talk about how we made this solution.
  We will explain our new DEX format with a new header, classes modification
  \dots~and how we maintain compatibility with post-invokedynamic APKs (cf.~\ref{newDEX}).
  How we represent the new constants and new instructions (cf.~\ref{newConst}).
  Also we will detail the most important implementation parts: method handles, invoke instructions, \dots~(cf.~\ref{implD}).
  At the end, we will describe our results in terms of execution time and code size.\\

  Our solution is not necessary fast, we have focussed on the conformance of the \JSR.
  To simplify the implementation, we have just integrated our solution in the ``portable'' interpreter written in C and not in assembler code.
  
\section{A new DEX format}
\label{newDEX}

  New instructions and constants imply new format of DEX file.
  Each DEX file version have a version number, our one is number 292.
  We enhance the opcode set, add constant-pools and change the header of classes.
  But we have to maintain the compatibility with the DEX files created before our version.

  \subsection{opcodes / constants}
    The \JSR needs two new constants (``const-methodtype'' and ``const-methodhandle'') and a new instruction (``invoke-dynamic'').
    Regarding the two methods ``invoke'' and ``invokeExact'', we made the choice to add two new instructions:
    ``invoke-exact'' for the ``invokeExact'' method and ``invoke-generic'' for the ``invoke'' method.
    The program ``dx'' (Figure \ref{DTC}) transforms virtual calls to ``invokeExact'' and ``invoke'' to instructions.

  \subsection{constant-pools}
    \label{CP}

    \DALVIK have a constant pool for each entry type.
    We have to add constant pool for each entry we need:
    MethodType, MethodHandle, InvokeDynamic and Bootstrap Arguments (Figure \ref{SNA}).

    \begin{figure}[!h]
      \centering \resizebox{.45\linewidth}{!}{\input{figures/tikz_struct_new_apk}}
      \caption{structure of new APK files.}
      \label{SNA}
    \end{figure}

    The MethodType entry contains an index into the prototype constant pool.
    The MethodHandle entry is described by the method handle kind (cf.~\ref{MH})
    and an index into the method or the field constant pool, according to the kind.
    The InvokeDynamic entry have indexes into the strings, the prototype,
    the method handle and the bootstrap arguments constant pools.
    And the BootstrapArguments entry contains its arguments number
    and a data block representing the arguments.
    Each argument is encoded with a tag
    followed by a constant pool index or the primitive value according to the tag (Figure \ref{CPentries}).

    \begin{figure}[!h]
      \centering \input{figures/snip_dvm_struct_mt}
      \centering \input{figures/snip_dvm_struct_mh}
      \centering \input{figures/snip_dvm_struct_indy}
      \centering \input{figures/snip_dvm_struct_bsm}\vspace{-1.5em}
      \caption{Constant pool entries.}
      \label{CPentries}
    \end{figure}

  \subsection{Class header}

    A call site is bound to an instruction so it is not interresting to store them into a constant-pool.
    So we have to create a table that contains the call sites.
    We have three ways to store the call sites: in the DEX header; in the method which contains the instruction and in the class where the method is.
    As a reminder, a DEX file describes all the classes of a program, and a class can have at most 65535 methods (cf.~jvms 4.11).
    A method can contain a lot of instruction and the call sites table can quickly overflow.
    The best solution is to store the call sites in the method, but \DALVIK does not have a lazy mecanism to create methods.
    All methods are created on class creation.
    Eventually, we store the table in the header of each class.

  \subsection{retro-compatibility}
    Our \ANDROID version understands post-invokedynamic APK.
    We need to modify the APK to add missing constant pools and CallSite tables.
    However APK are read-only.
    But the installation time optimizes and has to modify the APK using ``dexopt'' (Figure \ref{DTC}).
    We take advantage to the installation time to add our work.
    We just simulate an APK without MethodHandle, MethodType, CallSite, \dots~%
    Only the DEX header and classes header change, we add empty constant pools to the header
    and an empty table in each class representing the CallSite table.
    The size of the DEX header and classes change but no offsets.

\section{New opcodes}
\label{newConst}
  \subsection{New constants}

    We can create constant method handles only with the ``const-methodhandle'' instruction (Figure \ref{MTMHldc}) or in the arguments of a bootstrap method.
    The method handle instructions are rarely used and a bootstrap method is called once.
    Therefore it is not necessary to have a cache for method handles resolved.
    Resolve a method handle consists to find its informations into the constant-pool and create it.
    This creation can only do in Java, an up call is necessary.

    Comparing method types is common on the VM.
    To simplify and optimize these tests, we need to maintain a cache which make sure that two method types with the same signature are identicals.
    A method type can be create in Java or by the VM so the cache run in Java and only Java can create a method type (the VM does an up call).
    All method types are store in the cache and a test between two method types becomes a simply equality test.
    Resolve a method type consists to find its prototype in the constant-pool and call Java to find it or create it.
    We distinguish two types of method type: some are used by the VM (strong) and must not be freed by the GC; the others (weak) can be freed by the GC if necessary.

    \begin{figure}[!h]
      \centering \resizebox{.9\linewidth}{!}{\input{figures/inst_mh_mt}}
      \caption{methodtype and methodhandle constant.}
      \label{MTMHldc}
    \end{figure}

  \subsection{New invoke instructions}
    Each instruction have two representations: a ``normal'' form and a ``range'' form.
    The ``normal'' form represents the instruction with at most 5 registers.
    And the ``range'' form can have at most 65535 registers.
    Each register is considered 32 bits wide.

    \subsubsection{invoke-exact and invoke-generic}

      invoke-exact and invoke-generic (Figure \ref{INGEins}) contain an index in the constant-pool of method types.
      This method type represents the order and types of the arguments passed to the instruction, the first argument excluded.
      The first argument is the method handle we have to call.\\

      \begin{figure}[!h]
        \centering \resizebox{.9\linewidth}{!}{\input{figures/inst_gen_exa}}
        \caption{invoke-generic/exact instruction.}
        \label{INGEins}
      \end{figure}

    \subsubsection{invoke-dynamic}

      An invoke-dynamic (Figure \ref{INDYins}) contains an integer corresponding to the call site number and an index in the constant-pool of invoke-dynamic.
      This entry in the invoke-dynamic constant pool have all informations that we need to treat this instruction: bootstrap method, arguments, \dots (cf.~\ref{CP}).
      A new opcode format has been added.

      \begin{figure}[!h]
        \centering \resizebox{.9\linewidth}{!}{\input{figures/inst_indy}}
        \caption{invoke-dynamic instruction.}
        \label{INDYins}
      \end{figure}

\section{Implementation details}
\label{implD}

    \subsection{MethodHandle}
      Method handles can be divide in three parts (Figure \ref{mhHier}):
      \begin{itemize}
        \item direct method handles which are treated by a call to the method {\bf invoke} or {\bf invokeExact};
        \item combiners which require specific treatments;
        \item and invokers which simulate an ``invoke'' or ``invokeExact'' call.
      \end{itemize}

      \begin{figure}[!h]
        \centering \resizebox{\linewidth}{!}{\input{figures/tikz_mh_hierarchy}}
        \caption{Method handles hierarchy.}
        \label{mhHier}
      \end{figure}

      Each part gathers different kinds of method handle.
      The ``direct'' part contains all method handles which do an invoke (virtual, direct, static, \dots)
      and a field access (get, put) with a possible ``static'' and ``volatile'' form.
      The ``combiner'' part aggregates all method handles that we cannot call directly.
      We treat these method handles with a specific interpreter detailed in section \ref{combiners}.
      The last part ("invoker") is formed by special method handles which need a specific manipulation in the Dalvik interpreter.
      Each part is treated differently by the Dalvik interpreter.

      We distinguish all kinds of method handle with several binary masks to perform dispatch between the different treatments.

      \begin{figure}[!h]
        \centering \input{figures/snip_methodhandle}\vspace{-1.5em}
        \caption{Method handle fields.}
        \label{mhFields}
      \end{figure}

      A MethodHandle is describe by: the declaring class; the method type; the kind and the slot corresponding to the method/field/\dots

    \subsection{invoke instructions}
      All new instructions work with a method handle so we have written a method, inside the interpreter, which treats a method handle.
      It invokes the method, gets or sets a field and calls the method handle interpreter depending to the kind of the method handle.
      It also uses the interpreter mecanism to store the return value.
      This method is called ``invokeMethodHandle''.

    \subsubsection{invoke-exact and invoke-generic}
      invoke-exact is the instruction with the most simple implementation.
      If the two method types (contained in the instruction and in the method handle) are equals we call the method handle,
      else an exception is thrown.\\
      
      invoke-generic works like an invoke-exact but if the method types differ, we try to adapt arguments.
      Different treatments can be done:
      if the number of arguments is the same between the two method types, we try to convert arguments;
      if we have a variadic signature, we collect and convert arguments to match the method type of the method handle;
      else an exception is thrown.
      When the arguments match the method signature, we call the method handle.
  
    \subsubsection{invoke-dynamic}
      The call site is found in the current class but if it is the first time that we read this instruction, the call site is not created yet.
      In this case, we need to call the bootstrap method associated to the instruction first.
      So we decode the arguments of the bootstrap method and do an up call to the method ``callBootstrapMethod'' (Figure \ref{implBSM}).
      It returns a call site that is stored in the class.

      \begin{figure}[!h]
        \centering \input{figures/snip_meth_bsm}\vspace{-1.5em}
        \caption{snippet - ``callBootstrapMethod''.}
        \label{implBSM}
      \end{figure}

      A bootstrap method needs at least three arguments:
      a lookup (Lookup) that is a security token object encapsulating access rigths of class containing the invoke-dynamic opcode;
      an arbitrary name (String) specified as parameter of the invokedynamic opcode;
      a method type (MethodType), that is a reified object of the descriptor specified as parameter of the invoke-dynamic opcode;
      and any constant values specified as bootstrap arguments of the invoke-dynamic opcode.

      At first, we have to create the lookup from the given  declaring class.
      We treat the bootstrap method differently if arguments are given or not.
      If no argument are given, we call directly the bootstrap method
      with ``invokeExact'' and basic arguments (types are known).
      We add the basic arguments into the other arguments.
      We do not want strong method types into the bootstrap arguments,
      therefore they are represented by strings which are translated to method types.
      Because arguments are seen like an array of Object,
      we have to call the ``invoke'' method.
      The ``invoke'' method needs the true signature when it is called,
      so we have to dispatch arguments to create the real signature.
      To do that, we call the method ``invokeWithArguments'' (Figure \ref{implIWA})
      which calls the method invoke according to the number of arguments.
      ``invokeWithArguments'' is separated on many functions to allow optimizations by the JIT.

      \begin{figure}[!h]
        \centering \input{figures/snip_meth_iwa}\vspace{-1.5em}
        \caption{snippet - ``invokeWithArguments''.}
        \label{implIWA}
      \end{figure}

      When the callsite is returned, we verify its integrity.
      We check if it or its target is not null and if the target's type and the type given are the same.
      Because the target's callsite could be uninitialized we have to check if the target contains a method handle or a method type.

      When the bootstrap method returns its value, we have to store the call site.
      And because this instruction can be read by many threads, we use an atomic ``compare-and-set'' mecanism.
      When we have the call site, we get its method handle.
      All method handles are volatiles so we have to get it atomically.
      At the end, we call it.

    \subsection{Combiners}
    \label{combiners}

      A part of method handles allows to manipulate arguments, we call them: ``combiners''.
      Combiners can contain several method handles and at least one direct method handle.
      Thereby, we can represent them by trees, reffered to here as method handles trees.

      Executing a combiner is often equivalent to executing many.
      Given that combiners cannot be final calls,
      it is not interresting to do real calls, ie.~put on the execution stack,
      each combiner and at the end call the direct method handle, which needs a real call.

      To execute direct method handles, we have to use the ``invoke-exact'' and ``invoke-generic'' instructions.
      But we cannot call them through the interpreter, we can only do in Java.
      To avoid a Java up call for each combiner, we have chosen to write an interpreter,
      specific to execution of combiners, in Java (Figure \ref{implINTERP}).

      \begin{figure}[!h]
        \centering \input{figures/snip_meth_interp}\vspace{-1.5em}
        \caption{snippet - ``invokeCombiner''.}
        \label{implINTERP}
      \end{figure}

      This interpreter is implemented using a continuation mechanism (context) to treat the return value.
      Each combiner execute its own code and can produce a 'context'.
      For example, AsType converts arguments and produces a context if it has to convert the return value.
      When the interpreter treats a direct method handle,
      which means a method handle produced by a call to ``lookup.findXXX(\dots)'' (instance, static, getter, \dots),
      it does an invoke-generic and check if a context exist.
      If there is a context, the interpreter executes the second part of the method handle
      and convert the return value in the case of AsType.
      Afterwards, the interpreter repeats the loop.

      This implementation avoids to pile up a call in the stack for each method handle.
      We pile up only if we have a direct method handle, which is not a subtree.

    \subsection{Invokers}

      Among method handles, we call "invoker" those which are high order method handles.
      An invoker extracts the method handle passed as first pargument and calls it with the rest of arguments.
      Its job is to simulate a call to the method ``invokeExact'' (exactInvoker) and ``invoke'' (invoker).
      The method type of an invoker is the same as the method handle it have to call with a MethodHandle at first parameter.

      Because we cannot simulate an ``invoke-exact'' in Java, we have to add support code in the Dalvik interpreter.
      And to avoid unnecessary up calls, we treat the generic invoker in the interpreter too.
      Each invoker can be executed either by the ``invoke'' method or by the ``invokeExact'' method, so we have four call semantics.

      In the Dalvik interpreter, the execution of an invoker acts as an optimized tail call.
      The method handle to call (invokee) is extracted from the first argument and the other arguments are shifted.
      Then the interpreter executes itself again using a goto.
      In order to perform the second pointer check, we store the expected method type of the invokee as a field of the MHInvoker class (Figure \ref{invokeeFields}).

      \begin{figure}[!h]
        \centering \input{figures/snip_mh_invoker}\vspace{-1.5em}
        \caption{Method handle invokee fields.}
        \label{invokeeFields}
      \end{figure}

      A problem remains when we want to execute the generic invoker with the semantics of ``invoke-exact''.
      Reproducing the ``invoke-generic'' behaviour requires to copy a lot of code so,
      we choose to do an up call to the method ``invokeWithArguments'' which calls the method ``invoke''.

      Method handles contains also others invokers (``spreadInvoker'' and ``dynamicInvoker'') but we are able to treat them like combiners.

\section{Result}

  \noindent \fixme{impact sur le code source (dalvik/libcore)}\\
  \fixme{impact sur le binaire (dvm/dex)}

  To compare performances of new instructions and the reflection API,
  we have written a test which calls N times a method using differents ways (instructions and reflection).
  This test is executed using \DALVIK without graphical.

  \begin{figure}[!h]
    \resizebox{\linewidth}{!}{\input{figures/tikz_res_invokes}}
    \caption{JSR 292 instructions vs reflection API.}
    \label{Rinvoke}
  \end{figure}

  Figure \ref{Rinvoke} shows results for 10000, 100000 and 1000000.
  Below these values, we cannot see strictly the differences between each kind of execution.
  We notice that calls to ``invoke-exact'' and to ``invoke-generic'' with the right method type (behaving as an ``invoke-exact'') are faster than others.
  ``invoke-dynamic'' takes a bit more time because it have to get a volatile method handle.
  Regarding ``invoke-generic'' with a method type different to the final call, the execution time increases.
  This difference is due to the boxing mecanism which creates new objects.
  However, ``invoke-generic'' remains faster than the reflection API which requires to box all arguments and create an array of Object.\\
  
  Another test executes the example described in this article.
  We call N times a method which takes an Object and calls the right method according to the dynamic type of the argument.
  We compare the execution time of the example using the instanceof mecanism, the reflection API and the method handle interpreter.

  \begin{figure}[!h]
    \resizebox{\linewidth}{!}{\input{figures/tikz_res_mutable}}
    \caption{Method handle interpreter vs instanceof vs reflection API.}
    \label{Rmutable}
  \end{figure}

  We notice on Figure \ref{Rmutable} that our method handle interpreter is really slow.
  The method handle interpreter manipulates arguments.
  It have to create an array each time a reduce or an increase of the arguments number happens.

\section{Related Works}

  Currently, the OpenJDK is the only open-source implementation of the \JSR.
  This JSR has often evolved since its request in 2006\cite{jcp-jsr-292}.
  In 2009, a paper of John R. Rose (\JSR spec leader) describes an implementation of the \Jsr, now obsolete\cite{vmil-rose-indy-2009}.
  In 2010, John R. Rose and al. published a paper presenting the implementation in the JDK 7\cite{pppj-rose-indy-2010}.
  Today, no paper explains the LambdaForm-based implementation of the JDK 8.

  We don't find any implementation of the \JSR on an embedded virtual machine.
  Note also that the \Jsr 360 (describing the embedded part of the JDK) specify that the ``invokedynamic'' instruction is not included\cite{jcp-jsr-360}.

\appendix
\section{Appendix Title}

\noindent \fixme{lien vers bitbucket}\\
\fixme{expliquer comment compiler}

\section{Acknowledgments}

\noindent \fixme{Acknowledgments, if needed.}

% We recommend abbrvnat bibliography style.

\makeatletter
  \def\@seccntformat#1{Appendix~\csname the#1\endcsname:\quad}
\makeatother

% \bibliographystyle{abbrvnat}
\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.
\begin{thebibliography}{}
%   \softraggedright

  \bibitem{idc-website}
  IDC website (2013) - \\ \url{www.idc.com/getdoc.jsp?containerId=prUS24257413}.

  \bibitem{ieee-butler-android-landscape}
  Butler, M., ``Android: Changing the Mobile Landscape'', Pervasive Computing, IEEE , vol.10, no.1, pp.4,7, Jan.-March 2011.

  \bibitem{ieee-paulson-shift-dynamic-languages}
  Paulson, L.D., ``Developers shift to dynamic programming languages'', Computer , vol.40, no.2, pp.12,15, Feb. 2007.

  \bibitem{ieee-paul-kundu-energy-perspective}
  Paul, K.; Kundu, T.K., ``Android on Mobile Devices: An Energy Perspective'', Computer and Information Technology (CIT), 2010 IEEE 10th International Conference on , vol., no., pp.2421,2426, June 29 2010-July 1 2010.

  \bibitem{wiki-android}
  \ANDROID (Wikipedia) - \\ \url{http://en.wikipedia.org/wiki/Android\_(operating\_system)#Linux}.

  \bibitem{wiki-jvm-lang}
  \JVM languages (Wikipedia) - \\ \url{http://en.wikipedia.org/wiki/List\_of\_JVM\_languages}.

  \bibitem{lang-groovy}
  Groovy website - \\ \url{http://groovy.codehaus.org/}.
  
  \bibitem{jvmsummit-heidinga-mhimpl-2010}
  Heidinga, D., ``MethodHandles: An IBM Implementation'', In {\it JVM Summit}, 2010. \url{http://wiki.jvmlangsummit.com/images/a/ad/J9_MethodHandle_Impl.pdf}.

  \bibitem{jvmsummit-heidinga-mhimpl-2011}
  Heidinga, D., ``MethodHandle implemention tips and tricks'', In {\it JVM Summit}, 2011. \url{http://wiki.jvmlangsummit.com/images/6/6b/2011_Heidinga.pdf}.

  \bibitem{jvmsummit-rose-mhimpl-2011}
  Rose, J.R., ``Method Handles and Beyond\dots~Some basis vectors'', In {\it JVM Summit}, 2011. \url{http://wiki.jvmlangsummit.com/images/8/88/Rose-2011-FutureDirections.pdf}.

  \bibitem{jcp-jsr-292}
  Java Community Process, ``JSR 292: Supporting Dynamically Typed Languages on the Java{\scriptsize\texttrademark} Platform'' - \url{https://jcp.org/en/jsr/detail?id=292}.

  \bibitem{vmil-rose-indy-2009}
  Rose, J.R., ``Bytecodes meet combinators: invokedynamic on the JVM''. In {\it Proceedings of the 3rd Workshop on Virtual Machines and Intermediate Languages (VMIL)}, 2009.

  \bibitem{pppj-rose-indy-2010}
  Thalinger, C.; Rose, J.R., ``Optimizing invokedynamic''. In {\it Proceedings of the 8th International Conference on the Principles and Practice of Programming in Java (PPPJ)}, 2010.

  \bibitem{jcp-jsr-360}
  Java Community Process, ``JSR 360: Connected Limited Device Configuration 8'' - \url{https://jcp.org/en/jsr/detail?id=360}.

\end{thebibliography}


\end{document}

%                       Revision History
%                       -------- -------
%  Date         Person  Ver.    Change
%  ----         ------  ----    ------

%  2013.06.29   TU      0.1--4  comments on permission/copyright notices

