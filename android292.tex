\documentclass{sig-alternate}

\usepackage{refcheck}

\usepackage{tikz}
\usetikzlibrary{plotmarks,shapes,arrows,positioning}
\usepackage{pgfplotstable}
\pgfplotsset{compat=newest}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{stfloats}
\usepackage{hyperref}
\hypersetup{
%    bookmarks=false,        % show bookmarks bar?
    unicode=false,          % non-Latin characters in Acrobat’s bookmarks
    pdftoolbar=true,        % show Acrobat’s toolbar?
    pdfmenubar=true,        % show Acrobat’s menu?
    pdffitwindow=false,     % window fit to page when opened
    pdfstartview={FitH},    % fits the width of the page to the window
    pdftitle={My title},    % title
    pdfauthor={Author},     % author
    pdfsubject={Subject},   % subject of the document
    pdfcreator={Creator},   % creator of the document
    pdfproducer={Producer}, % producer of the document
    pdfkeywords={keyword1} {key2} {key3}, % list of keywords
    pdfnewwindow=true,      % links in new window
    colorlinks=true,        % false: boxed links; true: colored links
    linkcolor=black,        % color of internal links (change box color with linkbordercolor)
    citecolor=black,        % color of links to bibliography
    filecolor=black,        % color of file links
    urlcolor=black          % color of external links
}

\def \JCP{JCP\xspace}
\def \SUN{Sun Microsystems\xspace}
\def \ORACLE{Oracle\xspace}
\def \DALVIK{Dalvik\xspace}
\def \Jsr{JSR\xspace}
\def \JSR{\Jsr 292\xspace}
\def \GOOGLE{Google\xspace}
\def \ANDROID{Android\xspace}
\def \JVM{JVM\xspace}
\def \DEX{DEX\xspace}
\def \VM{VM\xspace}
\def \BSM{BSM\xspace}

\newcommand{\tinyline}[3]{
  \scriptsize #1 &
  \scriptsize #2 &
  \scriptsize #3\\
  \hline
}

\newenvironment{listminimal}[1]%
{ \begin{minipage}{#1}%
    \medskip
    \begin{list}%
      {}%
      {%
        \setlength{\labelwidth}{0pt}%
        \setlength{\leftmargin}{0pt}%
        \setlength{\itemsep}{1pt}%
        \setlength{\parskip}{0pt}%
        \setlength{\parsep}{0pt}}%
}%
{ \\ \end{list} \end{minipage} }

\newcommand{\fixme}[1]{{\color{red}FIXME #1}}

\begin{document}

\title{Android 292: implementing invokedynamic in Android}

\numberofauthors{3}
\author{
  \alignauthor Gilles Roussel\\
    \affaddr{University Paris-Est Marne-la-Vallee}\\
    \email{roussel@univ-mlv.fr}
  \alignauthor Remi Forax\\
    \affaddr{University Paris-Est Marne-la-Vallee}\\
    \email{forax@univ-mlv.fr}
  \alignauthor Jerome Pilliet\\
    \affaddr{University Paris-Est Marne-la-Vallee}\\
    \email{pilliet@univ-mlv.fr}
}

\conferenceinfo{JTRES}{2014 Niagara Falls, New York USA}
%\CopyrightYear{2007} % Allows default copyright year (20XX) to be over-ridden - IF NEED BE.
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data (0-89791-88-6/97/05) to be over-ridden - IF NEED BE.
% --- End of Author Metadata ---

\maketitle

\begin{abstract}
\ANDROID OS uses for its applicative part a Java-based virtual machine called Dalvik.
Java 7 introduces a new instructions set as well as a new API  specified by the \JSR~\cite{jcp-jsr-292}
in order to improve and simplify the implementation of non-Java languages on top of the Java Virtual Machine.
As far as we know, neither the JVMs that are compatible with Java ME 8 nor
\ANDROID, while compatible at syntactical level with Java 7, implement this \Jsr.
We believe this is due to the fact that current implementations for desktop and server rely
on code generation at runtime which requires too much computing power and energy.

This paper describes our implementation of the \JSR in Dalvik.
First, we adapt the class format specification of the \JSR which is stack based and implicitly relies on the fact that the bytecode
can be rewritten at runtime, to the opcode specification of Dalvik which is register based and read only. 
Then we explain, how we represent the different kinds of method handles in Java, and how the method handles are interpreted,
using either the C interpreter for the low level method handle or a Java flexible but slow interpreter for the ``combiner`` method handles.

At the end, we present a comparison of the execution time of the different kinds of calls.
This comparison shows that the implementation of the new instructions is faster than the reflection
although the Java interpreter of combiners is slowed down by frequent object creations.
\end{abstract}

\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore, 
% you may leave them out
% \terms
% term1, term2

\keywords
Bytecode, method invocation, invokedynamic, JSR 292,\\
method handles, method handle adapters, \ANDROID, Dalvik, embedded system

\newpage
\section{Overview}

  \subsection{\ANDROID}

    \ANDROID is a mobile operating system created by Google.
    It is an open-source project called ``\ANDROID Open-Source Project'' (AOSP).
    As of Q2 2013, \ANDROID occupies almost 80\% of the market share with more than 187 million units shipped~\cite{idc-website}.
    The success of \ANDROID can be explained by an open project and an open market,
    which are very attractive for device producers, service providers, and application developers
   ~\cite{ieee-butler-android-landscape}\cite{ieee-paulson-shift-dynamic-languages}.
    \ANDROID mainly runs on embedded environments like smartphones and tablets,
    and supports ARM, Intel and MIPS architecture.
    
    Even if hardware supporting \ANDROID become more efficient,
    devices cannot be as powerful as desktop computers because of miniaturization.
    Being a mobile device also requires a minimal energetic consumption.
    Moreover, \ANDROID is a portable system and adaptable to a huge number of different devices,
    forcing it to abstract itself from hardware.

    The \ANDROID architecture is described like a ``software stack'' (Figure~\ref{ASA}).
    It's composed of:
    \begin{itemize}
      \item a modified version of the Linux kernel.
        It offers hardware abstraction, memory management, process management, as well as a security model, and a network model;
      \item native libraries (C/C++),
        which provide most of features in the \ANDROID system;
      \item a virtual machine called ``\DALVIK''
        which executes the application written in Java but converted to the \DEX format.
        \DALVIK uses the core API of Java written from scratch
        which can be assimilated to the version 5 or 6 of the Java API;
      \item an application framework to make \ANDROID applications;
      \item default applications.
    \end{itemize}

    \begin{figure}[!ht]
      \centering \resizebox{\linewidth}{!}{\input{figures/tikz_struct_android}}
      \caption{\ANDROID system architecture~\cite{wiki-android}.}\vspace{-1em}
      \label{ASA}
    \end{figure}

    \subsubsection{Differences between the JVM and \DALVIK}

      The main difference between these two machines is that \DALVIK is register based while the \JVM is stack based.
      A stack based virtual machine (VM) uses more instructions to manipulate data and to implement Java code than a register based VM.
      But the register based VM instructions tend to be larger in terms of code size~\cite{ieee-paul-kundu-energy-perspective}.

      The Java bytecode is given in a ``.class'' file and contains the code of a unique class (Figure~\ref{SJA}).
      The file is made of a serie of tables which describe various information, the code of the class and some other things.
      The code contains references to these tables.
      Among these tables, the constant-pool stores most of the constant values of the class (numbers or texts)
      and more evolved elements (data types, class names, attribute names, \dots).

      \begin{figure}[!ht]
        \centering \resizebox{\linewidth}{!}{\input{figures/tikz_struct_jar_apk}}
        \caption{structure of JAR and APK files.}\vspace{-.5em}
        \label{SJA}
      \end{figure}

      In contrast, \DEX format contains all classes (".class" files) of the application (Figure~\ref{SJA}).
      It is a read-only format, loaded in one piece, so the code cannot be changed or modified at runtime.
      Duplicate constants, such as strings, used in multiple class files
      are included only once in the \DEX file to save space.
      Unlike the \JVM, \DALVIK uses one constant-pool based on the type of the constant
      except for the primitive types which are directly encoded within the opcode.
      It leads more smaller indexes for instructions.\\

      \begin{figure}[!ht]
        \centering \resizebox{\linewidth}{!}{\input{figures/tikz_dex_toolschain}}
        \caption{\ANDROID application tools-chain.}
        \label{DTC}
      \end{figure}

      \DALVIK cannot directly execute Java bytecode.
      It first has to translate the Java bytecode to \DEX (the \DALVIK specific bytecode),
      which can then be optimized (dxopt) in a binary format (\mbox{ODEX}) to save space (Figure~\ref{DTC}).

  \subsection{Java Specification Request 292}

    The \JSR is a request from \JCP and led by \SUN from 2006 to 2011.
    It had been integrated in 2011 in the version 7 of Java,
    modifying both the Java language specification and the \JVM specification.

    Since late 90's, a lot of language
    implementors have chosen the JVM as their target platform~\cite{wiki-jvm-lang},
    for several reasons such as the size of the ecosystem,
    the presence of mature GCs and Just In Time compilers (JITs).

    The aim of this \Jsr is to ease the implementation of dynamically typed languages
    by providing a new way to do function calls that allows language implementors
    to describe a specific semantics, independently of the semantics of the Java language.

    This \Jsr is composed of two parts, the first part, specifying the semantics of
    newly introduced opcodes and the second part defining an API: ``java.lang.invoke''.
    This API permits the creation of runtime type safe function pointers (as java.lang.invoke.MethodHandle)
    and methods to combine those pointers to do things like composition, argument conversions,
    argument permutations, \dots

    The next sections present the new API and instructions.
    But before that, we want to introduce an example that we will use for the rest of the paper.

    \subsubsection{Example}
      Let suppose we have the following code in Groovy~\cite{lang-groovy}:

      \input{figures/snip_foo_groovy}

      It prints {\it '11'} and {\it 'test2'}.
      For the first call to {\bf foo}, {\bf a} is an integer so the symbol {\bf +} refers
      to the function {\it +(int,int)} while for the second call to {\bf foo}, {\bf a} is a string, {\bf +} refers to the function {\it +(String,String)}.

      If one tries to translate this code to Java bytecode, it would be something like:

      \input{figures/snip_foo_bytecode}

      The Java bytecode is typed, each data manipulation instruction is prefixed 
      by the type of the operand ('a' for object, 'i' for integer, etc)
      and the method call (invokevirtual) specifies the type of the receiver and its parameters;
      an object (java/lang/Object) followed by an integer (I) (the first parameter represents the instance itself) ; and its return type
      which is also an object in the example.

      The code above does not work because invokevirtual is an existing Java bytecode that calls a virtual method using the Java semantics.
      The Java Virtual Machine or more precisely the bytecode verifier will check that
      there is an existing method '+' on java.lang.Object that takes an integer and returns an Object.
      In Java, this method does not exist. The bytecode verification will then fail.

      Another possible translation is to use a cascade of \emph{if ... instanceof}.

      \vspace{1em}

      \input{figures/snip_foo_java}

      While this code works, it supposes that all the potentials variations of + are known at compile time,
      something that is not true in most dynamically typed languages (Ruby, Groovy or Dart allows users to add
      new versions of any operations).
      This code can also be slow because in real languages, the number of if ... instanceof branches
      can be greater than a dozen. 

      To solve these issues, the \Jsr introduces a new bytecode named invokedynamic, which has no predefined
      linking semantics and lets an external Java\footnote{or any languages that can be compiled to Java bytecode} code
      named the bootstrap method to specify the linking semantics.
      This method returns a CallSite object that is a box that contains a method handle (a function pointer)
      that will be used for the subsequent calls.

      The classes (MethodHandle, MethodType, CallSite, etc.) specified by the \Jsr are grouped into a new
      package called ``java.lang.invoke'' and are directly understood by the \JVM.
      These classes answer to the problems coming from dynamically typed languages optimizations or implementations.

    \subsubsection{invoke-dynamic and MethodHandle}

      The bootstrap method is called the first time the invokedynamic opcode is encountered by the interpreter,
      with the context where the opcode is located i.e.~the declaring class (encapsulated in a Lookup object),
      a symbolic name and the declared parameter types as a MethodType.
      Any subsequent execution of the invokedynamic opcode will call the function pointer
      stored inside the CallSite object returned by the bootstrap method (Figure~\ref{indyFC}).

      \begin{figure}[!ht]
        \centering \resizebox{.8\linewidth}{!}{\input{figures/tikz_indy_instruction}}
        \caption{invokedynamic instruction execution.}
        \label{indyFC}
      \end{figure}
      
      For our example, the code of {\bf foo} with invokedynamic is

      \input{figures/snip_foo_indy}

      The first time that {\bf foo} is executed, the bootstrap method of the class RT will be called,
      with a lookup object corresponding to the class containing {\bf foo},
      the string {\bf ``+''} and a MethodType corresponding to the descriptor:\\``(LObject;I)LObject;'' (Figure~\ref{fooBSM}).
      Moreover, invokedynamic comes with an API that allows to create several data patterns
      dynamically and lazily like for example a tree of if ... instanceof branches.

      \begin{figure}[!ht]
        \centering \input{figures/snip_foo_bsm}\vspace{-1.5em}
        \caption{Example - bootstrap method.}
        \label{fooBSM}
      \end{figure}

    \subsubsection{MethodType}

      A method type represents the types of the arguments and the return value accepted and returned by a method handle,
      or expected by a method handle caller, i.e. a method type represents a method signature.

      All method types are immutable and can only be created by static factory methods,
      allowing implementation to intern them when necessary. 
      In our example, we need three method types (Figure~\ref{fooMTS}), one for each method that we have to call:
      the ``check'' method; and the two methods ``plus''.

      \begin{figure}[!ht]
        \centering \input{figures/snip_foo_methods}\vspace{-1.5em}
        \caption{Example - methods with method types.}\vspace{-1em}
        \label{fooMTS}
      \end{figure}

    \subsubsection{MethodHandle / MethodHandles}
      \label{MH}

      A method handle is a runtime type checked, directly executable reference to
      either an underlying method, constructor, field, or similar low-level operation.
      It can also represent a combiner operation that is the result of a high order function
      that takes one or more method handles as input and applies operations like an argument transformation,
      a function composition, etc.
      The former kind of method handle is called a {\it direct method handle},
      the later is called a {\it combiner method handle}.

      To guarantee runtime type safety, each method handle embodies a method type (of type java.lang.invoke.MethodType)
      that describes the parameter types and the return type that a method handle accepts.
      When a method handle is called, the method type is checked using different semantics depending on the
      type of call.

      There are two kinds of method handle call semantics:
      \begin{itemize}
        \item the exact call semantics, in that case, the declared type of the arguments (and return value) at a call site
              must be exactly the same as the types of the method type.
        \item the generic call semantics, in that case, the arguments can be converted using subtyping conversions,
              widening primitive conversions, boxing and unboxing conversions and varargs conversions
              as defined in the Java Language Specification.
      \end{itemize}
      None of these semantics implement the calling semantics as defined by the Java Virtual Machine Specification
      for classical Java method calls like invokestatic or invokevirtual
      \footnote{There is also a minor difference between the generic call semantics and the call semantics of
        the Java Language Specification, if the method is a varargs and the call as the same number of parameters as the method.
        The generic call semantics will not try to do the varargs conversion if the last parameter is not an array.}.
      The exact call semantics is more strict, and the generic call semantics is more permissive than the classical call semantics.

      \begin{figure}[!ht]
        \centering \input{figures/snip_foo_change}\vspace{-1.5em}
        \caption{Example - ``change'' method.}\vspace{-.7em}
        \label{fooCHANGE}
      \end{figure}

      Now, back to our example, in order to find the right target method (addition or concatenation),
      but for that we need to inspect the runtime type (the class exactly) of the argument of the call.
      The values of the arguments are not available when the bootstrap method is called at linking time,
      so we use an intermediary method, named {\bf change} in the code below (Figure~\ref{fooCHANGE}),
      that will be registered as target method for the first call.
      When this method will be called, the arguments are known, and we can decide which target method to call.

      \begin{figure}[!ht]
        \centering \input{figures/snip_foo_callsite}\vspace{-1.5em}
        \caption{Example - mutable call site.}\vspace{-1.5em}
        \label{fooMCS}
      \end{figure}

      Because the method {\bf change} can be called for any operations, neither the number of parameters nor the type
      of the parameters are known before the bootstrap method is called. So the method {\bf change} takes an array of
      Object as parameter, and the combiner asCollector and asType are used to do the argument transformations
      that will takes all the arguments and wrap them in an array of Object.

      Moreover, the semantics of invokedynamic allow the runtime to relink, by calling the method setTarget
      on a CallSite (see below). So the method {\bf change} takes a CallSite as first parameter, this parameter
      will be curried using the combiner bindTo.
       
      Thus, in the example, we convert each argument to an Object using asType,
      we collect them to form the array of Objects with asCollector and
      we add the call site at first argument with bindTo (Figure~\ref{fooMCS}).

      \noindent This adaptation forms the tree of the Figure~\ref{ast1}.

      % graph 1
      \begin{figure}[!ht]
        \centering \resizebox{.7\linewidth}{!}{\input{figures/tikz_ast_1}}
        \caption{Method handles tree - bootstrap method.}\vspace{-1em}
        \label{ast1}
      \end{figure}

      When the call site is created, the method handle tree is called, so the {\bf change} method is called.
      This method takes a look at the dynamic type of {\bf a} (e.g.~an integer),
      finds the corresponding implementation of the {\bf plus} method
      and then re-links a method handles tree represented by a combiner called {\bf GuardWithTest}
      which is equivalent to a test {\bf if .. then .. else}.

      There is no existing method handle in the API that are able to do a class check,
      but it's easy to construct one. The method named {\bf check} checks if an argument class
      is identical to a class object taken as parameter and this parameter is curried
      (using insertArguments) to the class we need to check.

      The {\bf GuardWithTest} combiner uses the {\bf check} method to verify the class of {\bf a}.
      If the type of {\bf a} is an integer it will directly call the same implementation of {\bf plus};
      otherwise as a fallback, it will call the method {\bf change} to find a new target method.

      In the example, in order to call the method {\bf check}, we have to adapt the arguments,
      the method is called with an Object and an integer, so we first need to drop the second
      argument with dropArguments and then insert the java.lang.Class corresponding to an integer
      (java.lang.Integer) with insertArguments.
      This adaptation forms the tree of the Figure~\ref{ast2}.

      % graph 2
      \begin{figure}[!ht]
        \hspace{-.6in} \resizebox{1.3\linewidth}{!}{\input{figures/tikz_ast_2}}
        \caption{Method handles tree - first call (integer).}\vspace{-1em}
        \label{ast2}
      \end{figure}

      If 'a' is a string, the method {\bf change} is called again,
      installing a new method handle tree testing if 'a' is a string in order to call {\it plus(String,int)Object}
      delegating to the previous method handle tree otherwise.
      This adaptation form the tree of the Figure~\ref{ast3}.

      % graph 3
      \begin{figure*}[!ht]
        \centering \resizebox{.8\linewidth}{!}{\input{figures/tikz_ast_3}}
        \caption{Method handles tree - second call (string).}\vspace{-1em}
        \label{ast3}
      \end{figure*}

    \subsubsection{CallSite}

      As we have seen, a CallSite is a holder for a MethodHandle, which is called its target.
      An invokedynamic instruction linked to a CallSite delegates all calls to the site's current target.
      A same CallSite object may be associated with several invokedynamic
      instructions\footnote{A CallSite can also be ``free floating'', associated with no invokedynamic,
      if you want to reuse the same mechanism to implement an interpreter in Java by example.}\\

      It has three immediate, concrete subclasses that may be either instantiated or subclassed:
      \begin{enumerate}
        \item \textbf{ConstantCallSite} : If the target is constant.
        \item \textbf{MutableCallSite}  : If the target change infrequently.
        \item \textbf{VolatileCallSite} : If the target has the volatile variable semantics.
      \end{enumerate}
      A non-constant call site may be relinked by changing its target, calling ``setTarget'' on the CallSite.
      The new target must have the same type as the previous one.

\section{\ANDROID 292}
  At the current time, there only exist two complete implementations of \JSR.
  %There are a few complete implementations of the \JSR, mostly two.
  The OpenJDK Hotspot which is the reference implementation of Java and is also used in the Oracle JDK
  and the IBM J9 implementation used in the IBM JDK.
  These implementations use several mechanisms, bytecode generation, bytecode rewriting, assembly generation
  \dots~\cite{jvmsummit-heidinga-mhimpl-2010}\cite{jvmsummit-heidinga-mhimpl-2011}\cite{jvmsummit-rose-mhimpl-2011}
  that are not suitable to use in an embedded virtual machine like \DALVIK,
  because of the computing power and the energy consumption required by such mechanisms.

  For this reason, we have developed a specific implementation of the \JSR for \DALVIK.

  Specifically for \ANDROID, because \ANDROID does not use the Java class file format specification,
  we have re-interpreted the part of the \JSR specification that describes the class file format
  in order to translate it into the DEX file format.
  We have also implemented a way to execute all APKs previously created to run with our modified VM.
  This work is described in section~\ref{newConst}.
  
  Section~\ref{implD} describes in detail the most important implementation part of our work,
  the execution of an invokedynamic opcode, a direct method handle, a combiner method handle or
  an invoker method handle by our modified VM.
  
  In section~\ref{result}, we describe our results in terms of execution time and code size of our changes
  compared to a pristine Dalvik VM (section~\ref{result}).\\

\section{A new DEX format}
\label{newDEX}

  The main differences between the Java class file format and the Dalvik DEX format are:
  \begin{itemize}
   \item There are several constant pools, one by type of constant.
         all are shared by the whole application
   \item The DEX format is mmapped\footnote{loaded in memory using mmap unix operation.}
    and read only at runtime.
  \end{itemize}
  
  This implies that we need to introduce new constant pools to support the new opcodes.
  Because constant pools are directly described in the header of the DEX,
  this requires a new header, making DEX file supporting the JSR 292 incompatible
  with previous DEX file.
  
  \subsection{opcodes / constants}
    The \JSR introduces 1 new opcode invokedynamic, changes the semantics of ldc (load constant)
    to support loading constant method types and constant method handles and enhances the semantics
    of invokevirtual for the method MethodHandle.invokeExact and MethodHandle.invoke.

    Instead of overloading the already existing semantics, in Dalvik, we introduce several new opcodes,
    ``invoke-dynamic'' that does an invokedynamic,
    ``const-methodtype'' and ``const-methodhandle'' that respectively load a constant method type
    and a constant method handle and ``invokeExact'' and ``invoke'' which require that the first parameter
    is a MethodHandle.

    The program ``dx'' (Figure~\ref{DTC}) was modified to take Java bytecode and 
    transform the Java opcode or Java invokevirtual to the corresponding instructions.

  \subsection{constant-pools}
    \label{CP}

    To support the newly introduced opcodes, we had to add 4 new constant pools,
    one for constant method type, one for constant method handle, one for invoke-dynamic
    and one for the bootstrap arguments. (Figure~\ref{SNA}).

    \begin{figure}[!ht]
      \centering \resizebox{.45\linewidth}{!}{\input{figures/tikz_struct_new_apk}}
      \caption{structure of new APK files.}
      \label{SNA}
    \end{figure}

    The MethodType entry contains an index into the prototype constant pool.
    The MethodHandle entry is described by the method handle kind (section.~\ref{MH})
    and an index into the method or the field constant pool, according to the kind.
    The InvokeDynamic entry have indexes into the strings, the prototype,
    the method handle and the bootstrap arguments constant pools.
    And the BootstrapArguments entry contains its arguments number
    and a data block representing the arguments.
    Each argument is encoded with a tag followed by a constant pool index or
    an immediate primitive value according to the tag (Figure~\ref{CPentries}).

    \begin{figure}[!ht]
      \centering \input{figures/snip_dvm_struct_mt}
      \centering \input{figures/snip_dvm_struct_mh}
      \centering \input{figures/snip_dvm_struct_indy}
      \centering \input{figures/snip_dvm_struct_bsm}\vspace{-1.5em}
      \caption{Constant pool entries.}
      \label{CPentries}
    \end{figure}

  \subsection{Class header}

    At runtime we need to associate the CallSite object returned by the bootstrap method
    to a live CallSite object. So in the VM we need a table that associate a CallSite
    \footnote{As an optimization, the current implementation does not store the CallSite
     but the target method handle, but the principle is the same.}
    to a specific opcode of a specific method.

    Given that in \DALVIK, the initialization of the Method structures is done when
    the class is initialized (when the vtable is filled), instead of storing a CallSite
    table in each method, we have decided to store this table at the class level.
    
    For that reason, the DEX format of a class has a supplementary field storing
    the number of all CallSites for every methods of that class. 
    This number is calculated when generating the DEX file by the program ``dx''.

  \subsection{retro-compatibility}
    \label{retro}

    As said previously, in order to introduce new constant pools, we had to change
    the header of a DEX file in an incompatible way.
    In order to support APK generated with an unaltered version of ``dx'',
    the DEX file need to be re-written something that the VM can not do
    because the DEX file is read only.

    \ANDROID has a mechanism that optimizes a DEX file at the installation of
    an APK using a program named ``dxopt'' (Figure~\ref{DTC}).
    We take advantage of this mechanism to rewrite at installation time the APK to use our DEX format.
    This rewrite is fast, because we only can copy the previous DEX file and only insert the
    constant pools for method types, method handles, invoke-dynamics and
    bootstrap arguments with a size of zero and add a 0 in the header of a class at the
    position corresponding to the CallSites table.
    The size of the DEX header and the class headers change but no offsets inside each parts.

\section{New opcodes}
\label{newConst}
  \subsection{New constants}

    There are two ways to create a constant method handle, either using the ``const-methodhandle''
    instruction (Figure~\ref{MTMHldc}) or as arguments of a bootstrap method.
    Given that the ``const-methodhandle'' instruction is rarely used and
    a bootstrap method is called once, we have chosen to not implement a cache
    of resolved method handle in the VM.

    Because we have chosen to create method handle in Java (section~\ref{implD}),
    resolving a constant method handle is done by resolving the corresponding information
    in the constant pool and create it by an up call to the Java side.

    While constant method handles are not interned by the VM, some of the constant method types,
    are interned by the VM. Because we implement the runtime safety check of the invoke-exact
    instruction by a pointer check on the method type, we need, a fast access to a method type object
    from an invoke-exact instruction and a way to intern the method type.
    The method types are interned in a cache in Java, again to avoid to do a VM native call
    when creating a method type and the VM maintains  a table of the resolved method types
    populated lazily the first time a reference to a method type by an invoke-exact instruction
    is decoded.

    Because the table of the resolved method types can be big and mostly empty if a program
    uses only a subset of classes contain in the DEX file, we have chosen to not iterate over this table when doing
    the marking phase of a GC but instead to keep the method type referenced by an instruction
    using a strong reference in the Java cache while a method type created by a user code in Java
    is hold by a weak reference and reclaimed by the GC if not be used anymore.    

    \begin{figure}[!ht]
      \centering \resizebox{1.\linewidth}{!}{\input{figures/inst_mh_mt}}
      \caption{methodtype and methodhandle constant.}\vspace{-1em}
      \label{MTMHldc}
    \end{figure}

  \subsection{New invoke instructions}
    Like any other invoke instructions of the DEX format,
    each invoke instruction has two representations: a ``normal'' form and a ``range'' form.
    The ``normal'' form represents the instruction in a compact way with at most 5 registers as argument 
    and the ``range'' form that can have at most 255 registers.

    \subsubsection{invoke-exact and invoke-generic}

      The instruction invoke-exact and invoke-generic (Figure~\ref{INGEins}) contain an index
      in the constant-pool of method types which are resolved lazily.
      This method type represents the order and types of the arguments passed to the instruction, the first argument excluded.
      The first argument is the method handle we have to call.\\

      \begin{figure}[!ht]
        \centering \resizebox{1.\linewidth}{!}{\input{figures/inst_gen_exa}}
        \caption{invoke-generic/exact instruction.}\vspace{-1em}
        \label{INGEins}
      \end{figure}

    \subsubsection{invoke-dynamic}

      An invoke-dynamic (Figure~\ref{INDYins}) contains an integer corresponding to the call site number
      and an index in the constant-pool of invoke-dynamic.
      The entry in the invoke-dynamic constant pool contains a name, a prototype, a bootstrap method and an index to
      the bootstrap arguments. 
      Because the invoke-dynamic instruction is resolved once, the method type corresponding to the call
      is created once when the bootstrap method is called and not stored in the VM table.

      \begin{figure}[!ht]
        \centering \resizebox{1.\linewidth}{!}{\input{figures/inst_indy}}
        \caption{invoke-dynamic instruction.}\vspace{-1em}
        \label{INDYins}
      \end{figure}

\section{Implementation details}
\label{implD}

    \subsection{MethodHandle}
      We have chosen to divide the method handle in three kinds (Figure~\ref{mhHier})
      depending on how we have decided to implement calls:
      \begin{itemize}
        \item direct method handles are implemented inside the C interpreter
              either by a classical call (virtual, direct, static, \dots)
              or by a field access (get, put) with a possible ``static'' and ``volatile'' variation ;
        \item combiners are implemented by a Java interpreter detailed in section~\ref{combiners};
        \item and invokers which are also implemented in the C interpreter but using a form of tail call
              detailed in section~\ref{invokers}.
      \end{itemize}

      To perform some optimizations, we cannot treat at the same way these three kinds of method handles.
      Basically, the C implementation avoids unnecessary boxing and to pile up the execution stack.
      On the other hand, the Java implementation simplify argument manipulations.

      \begin{figure}[!ht]
        \centering \resizebox{\linewidth}{!}{\input{figures/tikz_mh_hierarchy}}
        \caption{Method handles hierarchy.}
        \label{mhHier}
      \end{figure}

      In term of Java Class hierarchy, the direct method handles are represented by the class MethodHandle,
      the combiners are represented by subclasses of the class InterpretMH which is a subclass of MethodHandle
      and the combiners are represented by the class Invoker which is a subclass of MethodHandle.

      \begin{figure}[!ht]
        \centering \input{figures/snip_methodhandle}\vspace{-1.5em}
        \caption{Method handle fields.}
        \label{mhFields}
      \end{figure}

      A MethodHandle is described by: the declaring class of the method to call/field to access;
      the method type; the kind and the slot which is an index to the method for non virtual method,
      a vtable/itable index for the virtual call/interface call and an offset inside the data structure
      for the fields (Figure~\ref{mhFields}).
      The field {\bf kind} of MethodHandle is used to indicate the kind of method handle inside the C interpreter and we use
      several bits masks to dispatch between the different treatments.

      We have decided to create the method handles in Java and not in the VM.
      For a direct method handle created using the Lookup API, these methods first check
      if the target method exists in the class using a native method and then create
      the method handle in Java. As in our example, we suppose that these methods are
      mostly stored inside static final fields thus their cost of creation is amortized.
      For the other method handles, they are usually created more frequently
      and do not require any action by the VM thus are fully created in Java.

    \subsection{invoke instructions}
      All new invoke instructions work the same way by first extracting the method handle
      and then depending on the value field {\bf kind} calling a function inside the interpreter.
      For invoke-exact and invoke-generic, the method handle is extracted from the stack and
      the other arguments are shifted in order to be able to reuse the function already existing in the interpreter
      to call a method or extract the value of a field.
      For invoke-dynamic, the method handle is extracted from the callsite table (using a volatile read see below)
      and the arguments are already at the right position.

    \subsubsection{invoke-exact and invoke-generic}
      The instruction invoke-exact is the instruction with the most simple implementation.
      If the reference of the two method types (the one contained in the instruction and the one inside the method handle)
      are identical, we just call the shared code that invokes a method handle,
      otherwise an exception WrongMethodTypeException is thrown.\\
      
      invoke-generic works like an invoke-exact but if the method types differ, instead of throwing an exception,
      we first try to adapt arguments.
      If the number of arguments is the same between the two method types, we try to convert arguments;
      if we have a variadic signature, we collect and convert arguments to match the method type of the method handle;
      otherwise an exception is thrown.
      If all the conversions works, we call the shared code that invoke the method handle.
  
    \subsubsection{invoke-dynamic}
      To find the method handle to call, we find the class that contains the current opcode,
      use the callsite index to get the method handle
      in the callsite table associated with the current class.
      If the pointer is null, it means that the bootstrap method was not called,
      so we decode the bootstrap argument and do an up call to a Java method named ``callBootstrapMethod'' (Figure~\ref{implBSM})
      inside MethodHandle that will call the bootstrap method in Java.
      % (using invokeWithArguments (Figure~\ref{implIWA}) which is based on invoke-generic).
      
      \begin{figure}[!ht]
        \centering \input{figures/snip_meth_bsm}\vspace{-1.5em}
        \caption{snippet - ``callBootstrapMethod''.}\vspace{-1em}
        \label{implBSM}
      \end{figure}

      The bootstrap method returns a CallSite, the code checks that the CallSite as the right MethodType
      and a target with the right MethodType and will store the target of the CallSite inside the table
      associated with the current class.

      Because several threads may execute a code containing the same invoke-dynamic instruction
      at the same time, this code is racy. In order to be sure that every thread sees the same CallSite
      after the initialization, the read inside the CallSites table is a volatile read and the write
      is done using a compare-and-set with null as expected value.
      If the compare-and-set fails, we re-read the CallSites table at the right index again with the volatile semantics
      and call the method handle which is guaranteed to be non-null.   

%       \begin{figure}[!ht]
%         \centering \input{figures/snip_meth_iwa}\vspace{-1.5em}
%         \caption{snippet - ``invokeWithArguments''.}
%         \label{implIWA}
%       \end{figure}


    \subsection{Combiners}
    \label{combiners}

      A combiner is a method handle that combines several method handles and when invoked
      does things like argument conversions, method folding, or {\bf if .. then .. else}.
      Because a combiner delegates a part of its invocation to other method handles,
      it can be seen as a tree with the combiners as internal nodes and the direct
      method handles as leafs.

      Standart edition Java defines a large number of combiners and some may be introduced in the next version
      of the Java\footnote{A new combiner was proposed for Java 8 but was eventually rejected just before the release.}.
      Thus we have decided to implement the interpreter of these combiners in Java
      to be more flexible and avoid to bloat the code of the VM even if the execution may be slower.
      
      When a combiner is called, the C interpreter will box all the argument values inside an array of Object
      and then do an up call to call a Java code that will modify the arguments by modifying the array
      of objects and then will use invoke-generic (exactly invokeWithArguments that use invoke-generic)
      to re-transform the Object back to their real values.  

      Executing a combiner is often equivalent to executing several other method handle
      combiners before executing a direct method handle at the end of the chain.
      Therefore we have decided to not implement the Java interpreter as a classical
      tree interpreter in order to avoid a sequence of up call/down call because while
      the combiner interpreter is written in Java, ``invoke-exact'' and ``invoke-generic'' instructions
      are handled by the C interpreter and to avoid to push too many stack frames that may blow the stack.
      
      \begin{figure}[!ht]
        \centering \input{figures/snip_meth_interp}\vspace{-1em}
        \caption{snippet - ``invokeCombiner''.}
        \label{implINTERP}
      \end{figure}

      The Java interpreter (Figure~\ref{implINTERP}) is implemented using a continuation mechanism
      ({\bf context}) that will remember how the return value of a specific combiner must be processed.
      For example, the combiner AsType converts the arguments and produces a context if it has
      to convert the return value and then the interpreter compute the next combiner using a loop until it calls
      a direct method handle that will return a return value. At the point the contexts will be unwinded
      to execute the conversion on the return value specified by AsType. 

      So only calls to direct method handles go to the C interpreter.
      Otherwise, the execution of the combiners is done inside the loop of the Java interpreter.

    \subsection{Invokers}
     \label{invokers}

      Among the method handles, the \JSR called ``invokers'' those which are high order method handles i.e.
      a method handle that has its first argument that is a method handle and that when invoked,
      extract the first argument and call it with with the rest of arguments.

      The invoker that simulates an invoke-exact is called exactInvoker, and the one that simulates
      an invoke-generic is called invoker. The method type of an invoker is the same as the method handle
      it has to call with a MethodHandle at first parameter.
      Each invoker can be executed either by a call to the method ``invoke'' or by a call to the method ``invokeExact'',
      so there are four call semantics.
      
      We cannot simulate the semantics of an invoke-exact call in the Java combiner interpreter
      (when the Java interpreter is called the arguments are boxed) and to avoid an unnecessary up call
      for the invoker (the one with the invoke-generic semantics), the exact invoker and the generic invoker
      are handled by the C interpreter.
      
      In the C interpreter, the execution of an invoker acts as a tail call,
      the method handle to call (the invokee) is extracted from the first argument and the other arguments are shifted.
      then the interpreter re-executes itself again using a goto.
      In order to perform the second pointer check, we store the expected method type of the invokee as a field of the MHInvoker class
      (Figure~\ref{invokeeFields}).

      \begin{figure}[!ht]
        \centering \input{figures/snip_mh_invoker}\vspace{-1.5em}
        \caption{Method handle invokee fields.}
        \label{invokeeFields}
      \end{figure}

      In the special case where the generic invoker is invoked with the semantics of invoke-exact,
      we choose to do an up call to the method ``invokeWithArguments'' which calls the method ``invoke''.

      The method handle API contains other invokers (the ``spreadInvoker'' and the ``dynamicInvoker'')
      but we are able to handle them as combiners.

\section{Results}
 \label{result}

  The modifications made to implement the \JSR have a cost in terms of size of code.
  About 2600 lines of code were required to tell {\bf dx} how to translate the new instructions,
  3200 lines of codes are added into Dalvik excluding duplications of code for each interpreter generated by \ANDROID itself.
  And finally, the introduction of the package ``java/lang/invoke'' required about 7000 lines of code of Java code.

%   \fixme{impact sur le binaire (4.4.3/4.4.3.292) libdvm(718992/739484) [20k]; android.jar(20522674/20533106) [20k]; dalvikvm(9500/9500)}

  In terms of binary size, the library containing the interpreter (libdvm.so) increases by twenty kilo-bytes
  as well as the Java API in the SDK (android.jar).
  A DEX file size using the new encoding increases proportionally in respect to the number of classes.
  Figure~\ref{Rsize} shows some DEX file sizes contained in \ANDROID but
  the impact of the new DEX file format is negligible if the program does not use the \JSR opcodes.

  \begin{figure}[!ht]
    \pgfplotstableread{
      %4.4.3    %4.4.3.292
0     2056     2088
1      696      732
2      700      736
3     5728     5764
4     1444     1476
    }\dataset
    \resizebox{.9\linewidth}{!}{\input{figures/tikz_res_sizes}}
    \caption{DEX file size comparison.}
    \label{Rsize}
  \end{figure}

  To compare performances of new instructions and the reflection API,
  we have written a test which calls N times a method using different ways (instructions and reflection).
  This test is executed using \DALVIK in command line mode.

  \begin{figure}[!ht]
    \resizebox{\linewidth}{!}{\input{figures/tikz_res_invokes}}
    \caption{JSR 292 instructions vs reflection API.}
    \label{Rinvoke}
  \end{figure}

  Figure~\ref{Rinvoke} shows results for 10000, 100000 and 1000000 executions.
  Below these number of executions, we cannot see any real the differences between each kind of invocation.
  Calls to ``invoke-exact'' and to ``invoke-generic'' with the right method type (behaving as an ``invoke-exact'') are faster than others,
  ``invoke-dynamic'' takes a bit more time because of the volatile load to get the method handle.
  Regarding ``invoke-generic'' with a method type different from the target method handle type, the execution time increases.
  due to the boxing mechanism which creates new objects at each call.
  However, ``invoke-generic'' remains faster than the reflection API which requires to box all arguments and create an array of Object.\\
  
  Another test executes the example described in this article.
  We call N times a method which takes an Object and calls the right method according to the dynamic type of the argument.
  We compare the execution time of the example using the instanceof mechanism, the reflection API and the method handle interpreter.

  \begin{figure}[!ht]
    \resizebox{\linewidth}{!}{\input{figures/tikz_res_mutable}}
    \caption{Method handle interpreter vs classic Java calls.}\vspace{-1em}
    \label{Rmutable}
  \end{figure}

  We notice on Figure~\ref{Rmutable} that our method handle interpreter is really slow,
  due to the fact that in order to call the Java method handle interpreter the arguments need to be boxed creating a lot of objects.

\section{Related Work}
  Because there are few implementations of the \JSR and that the IBM J9 implementation is done behind close doors,
  there are not a lot of published paper on that subject.

  In 2009, a paper of John R. Rose, the spec leader of the \JSR describes an implementation of the \JSR,
  now obsolete~\cite{vmil-rose-indy-2009}. In 2010, another paper by John R. Rose and Christian Thalinger present the implementation
  that was released with the OpenJDK 7~\cite{pppj-rose-indy-2010}. This implementation was thrown own and a new one, named lambda-form,
  was developed and shipped with the release of the OpenJDK 8. As far as we know, there is no published paper on this approach.

  In embedded space, JamVM supports the \JSR but its implementation re-use the OpenJDK 8 classes.
  The \Jsr 360, that describes the CLDC 8 version of Java explicitly specifies that
  an embedded JVM does not have to support the  ``invokedynamic'' instruction~\cite{jcp-jsr-360}.
  
\section{Conclusion}
  In this paper, we have shown how the \JSR can be re-interpreted for the \ANDROID DEX format and
  implemented in the context of a VM running on embedded devices.

  Our implementation associates the ``invoke'' and ``invokeExact'' methods to specific instructions,
  modifies the C interpreter to execute direct method handles and invokers, uses a Java interpreter to support execution of combiner method handles.
  As we noted, the execution times of the new instructions are better than their reflection counterpart,
  however, the combiner method handle interpreter suffers a lot of slowing down due to its frequent object creations.

  To solve this problem, we will envisage to reduce the number of object creation by creating a Java representation of
  a C interpreter stack frame allowing to shuffle the arguments without doing the boxing/unboxing operations that
  makes the current implementation slow.

\appendix

% We recommend abbrvnat bibliography style.

\makeatletter
  \def\@seccntformat#1{Appendix~\csname the#1\endcsname:\quad}
\makeatother

% \bibliographystyle{abbrvnat}
\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.
\begin{thebibliography}{}
%   \softraggedright

  \bibitem{idc-website}
  IDC website (2013) - \\ \url{www.idc.com/getdoc.jsp?containerId=prUS24257413}.

  \bibitem{ieee-butler-android-landscape}
  Butler, M., ``\ANDROID: Changing the Mobile Landscape'', Pervasive Computing, IEEE , vol.10, no.1, pp.4,7, Jan.-March 2011.

  \bibitem{ieee-paulson-shift-dynamic-languages}
  Paulson, L.D., ``Developers shift to dynamic programming languages'', Computer , vol.40, no.2, pp.12,15, Feb. 2007.

  \bibitem{ieee-paul-kundu-energy-perspective}
  Paul, K.; Kundu, T.K., ``\ANDROID on Mobile Devices: An Energy Perspective'', Computer and Information Technology (CIT), 2010 IEEE 10th International Conference on , vol., no., pp.2421,2426, June 29 2010-July 1 2010.

  \bibitem{wiki-android}
  \ANDROID (Wikipedia) - \\ \url{http://en.wikipedia.org/wiki/Android\_(operating\_system)#Linux}.

  \bibitem{wiki-jvm-lang}
  \JVM languages (Wikipedia) - \\ \url{http://en.wikipedia.org/wiki/List\_of\_JVM\_languages}.

  \bibitem{lang-groovy}
  Groovy website - \\ \url{http://groovy.codehaus.org/}.
  
  \bibitem{jvmsummit-heidinga-mhimpl-2010}
  Heidinga, D., ``MethodHandles: An IBM Implementation'', In {\it JVM Summit}, 2010. \url{http://wiki.jvmlangsummit.com/images/a/ad/J9_MethodHandle_Impl.pdf}.

  \bibitem{jvmsummit-heidinga-mhimpl-2011}
  Heidinga, D., ``MethodHandle implemention tips and tricks'', In {\it JVM Summit}, 2011. \url{http://wiki.jvmlangsummit.com/images/6/6b/2011_Heidinga.pdf}.

  \bibitem{jvmsummit-rose-mhimpl-2011}
  Rose, J.R., ``Method Handles and Beyond\dots~Some basis vectors'', In {\it JVM Summit}, 2011. \url{http://wiki.jvmlangsummit.com/images/8/88/Rose-2011-FutureDirections.pdf}.

  \bibitem{jcp-jsr-292}
  Java Community Process, ``JSR 292: Supporting Dynamically Typed Languages on the Java{\scriptsize\texttrademark} Platform'' - \url{https://jcp.org/en/jsr/detail?id=292}.

  \bibitem{vmil-rose-indy-2009}
  Rose, J.R., ``Bytecodes meet combinators: invokedynamic on the JVM''. In {\it Proceedings of the 3rd Workshop on Virtual Machines and Intermediate Languages (VMIL)}, 2009.

  \bibitem{pppj-rose-indy-2010}
  Thalinger, C.; Rose, J.R., ``Optimizing invokedynamic''. In {\it Proceedings of the 8th International Conference on the Principles and Practice of Programming in Java (PPPJ)}, 2010.

  \bibitem{jcp-jsr-360}
  Java Community Process, ``JSR 360: Connected Limited Device Configuration 8'' - \url{https://jcp.org/en/jsr/detail?id=360}.

  \bibitem{bb-libcore}
  BitBucket, ``Libcore 292'' - \url{https://bitbucket.org/jpilliet/libcore-292}.

  \bibitem{bb-dalvik}
  BitBucket, ``Libcore 292'' - \url{https://bitbucket.org/jpilliet/dalvik-292}.

  \bibitem{bb-android}
  BitBucket, ``Libcore 292'' - \url{https://bitbucket.org/jpilliet/android-292}.

  \bibitem{android-sources}
  \ANDROID, ``Initializing a Build Environment'' - \url{https://source.android.com/source/initializing.html}.

\end{thebibliography}

\section{Get and compile the project}

  Our project is divided into several parts.
  The main parts are the changes to the Java API (libcore-292~\cite{bb-libcore}) and those of Dalvik and ``dx'' (dalvik-292~\cite{bb-dalvik}).
  To compile our project, you need to download each part and sources of \ANDROID.
  To simplify this task, we put a project on BitBucket called ``\ANDROID 292''~\cite{bb-android}.
  Once recovered, a python script (aosp.py) allows to recover the entire project:

  {\scriptsize \begin{verbatim}
    python aosp.py
  \end{verbatim}}\vspace{-.8em}

  To compile the project, you must be on a GNU/Linux 64bits machine and initialize your environment to compile the AOSP~\cite{android-sources}.
  Once your environment ready, type the following commands:
 
  {\scriptsize \begin{verbatim}
    export EXPERIMENTAL_USE_JAVA7=true
    source build/envsetup.sh
    lunch full-eng # see README.md for more details
    make
  \end{verbatim}}\vspace{-.8em}

  Once the project is compiled, you can run the emulator by typing:

  {\scriptsize \begin{verbatim}
    emulator
  \end{verbatim}}\vspace{-.8em}

  Be sure to use the ``portable'' interpreter:

  {\scriptsize \begin{verbatim}
    adb shell stop
    adb shell setprop dalvik.vm.execution-mode int:portable
    adb shell start
  \end{verbatim}}\vspace{-.8em}

  Regarding the SDK, the commands are:

  {\scriptsize \begin{verbatim}
    export EXPERIMENTAL_USE_JAVA7=true
    source build/envsetup.sh
    lunch sdk-eng
    make sdk
  \end{verbatim}}\vspace{-.8em}

  The compiled project will produce an archive named:\\
  ``android-sdk\_eng.{\it XXX}\_linux-x86.zip''
  ({\it XXX} fits your login).
  Unzip it and add the SDK to your IDE as a classic \ANDROID SDK.


\end{document}

%                       Revision History
%                       -------- -------
%  Date         Person  Ver.    Change
%  ----         ------  ----    ------

%  2013.06.29   TU      0.1--4  comments on permission/copyright notices
